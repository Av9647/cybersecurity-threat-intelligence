#!/usr/bin/env python3
"""
1) Drop & recreate map and meta collections with the required unique indexes.
2) Build raw NVD and CVE-ListV5 → vendor_raw / product_raw maps.
3) In Python, apply CIRCL-specific sanitization:
     • NVD: trim → lowercase → drop blank/n/a
     • CVE-ListV5: trim → lowercase → drop blank/n/a
   then re-group CVEs under those sanitized keys.
4) Record build counts into map_build_meta via upserts.
5) Create supporting indexes.
"""
from datetime import datetime, timezone
from pymongo import MongoClient

DB_NAME       = "cvedb"
NVD_COLL      = "cves"
CVELIST_COLL  = "cvelistv5"
MAP_NVD       = "map_vendor_product_nvd"
MAP_CVELIST   = "map_vendor_product_cvelistv5"
META_COLL     = "map_build_meta"
BATCH_SIZE    = 1000

client = MongoClient("mongodb://mongo:27017/")
db     = client[DB_NAME]
ts     = datetime.now(timezone.utc)

def sanitize_nvd_field(s: str) -> str | None:
    """
    For NVD‐derived vendor/product strings:
      - trim whitespace
      - drop if empty or 'n/a' or '*** n/a ***'
      - lowercase
      - leave hyphens, underscores, spaces, punctuation untouched
    """
    if not s: return None
    s2 = s.strip()
    if not s2: return None
    low = s2.lower()
    if low in ("n/a", "*** n/a ***"): return None
    return low

def sanitize_cvelist_field(s: str) -> str | None:
    """
    For CVE-ListV5-derived vendor/product strings:
      - trim whitespace
      - lowercase only
      - drop if empty or 'n/a' or '*** n/a ***'
      - leave hyphens, underscores, spaces, punctuation untouched
    """
    if not s: return None
    s2 = s.strip()
    if not s2: return None
    low = s2.lower()
    if low in ("n/a", "*** n/a ***"): return None
    return low

# 1) Drop & recreate
for coll in (MAP_NVD, MAP_CVELIST, META_COLL):
    db[coll].drop()
    db.create_collection(coll)

db[META_COLL].create_index(
    [("collection", 1), ("ts", 1)],
    unique=True,
    name="uniq_meta_collection_ts"
)

# 2a) Build raw NVD → vendor_raw / product_raw map
print("Building raw map_vendor_product_nvd…")
pipeline_nvd = [
    {"$unwind": "$configurations"},
    {"$unwind": "$configurations.nodes"},
    {"$unwind": "$configurations.nodes.cpeMatch"},
    {"$project": {
        "cve":        "$id",
        "vendor_raw":  {"$arrayElemAt":[{"$split":["$configurations.nodes.cpeMatch.criteria", ":"]}, 3]},
        "product_raw": {"$arrayElemAt":[{"$split":["$configurations.nodes.cpeMatch.criteria", ":"]}, 4]}
    }},
    {"$group": {
        "_id": {"vendor": "$vendor_raw", "product": "$product_raw"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$merge": {
        "into": MAP_NVD, "on": "_id",
        "whenMatched": "replace", "whenNotMatched": "insert"
    }}
]
db[NVD_COLL].aggregate(pipeline_nvd, allowDiskUse=True)
raw_nvd = db[MAP_NVD].count_documents({})
print(f" → {raw_nvd:,} raw NVD entries")

# 2b) Build raw CVE-ListV5 → include both cna.affected and adp
print("Building raw map_vendor_product_cvelistv5…")
pipeline_cl = [
    # pull the two source arrays into one
    {"$project": {
        "cve": "$cveMetadata.cveId",
        "all_aff": {
            "$concatArrays": [
                {"$ifNull": ["$containers.cna.affected", []]},
                {"$ifNull": ["$containers.adp", []]}
            ]
        }
    }},
    {"$unwind": "$all_aff"},
    {"$project": {
        "cve":         1,
        "vendor_raw":  "$all_aff.vendor",
        "product_raw": "$all_aff.product"
    }},
    {"$group": {
        "_id": {"vendor": "$vendor_raw", "product": "$product_raw"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$merge": {
        "into": MAP_CVELIST, "on": "_id",
        "whenMatched": "replace", "whenNotMatched": "insert"
    }}
]
db[CVELIST_COLL].aggregate(pipeline_cl, allowDiskUse=True)
raw_cl = db[MAP_CVELIST].count_documents({})
print(f" → {raw_cl:,} raw CVE-ListV5 entries")

# 3) Transform & re-group into sanitized maps
def transform_map(src_coll: str, dst_coll: str, sanitizer):
    cursor = db[src_coll].find({}, {"_id":1, "cves":1})
    merged: dict[tuple[str,str], set[str]] = {}

    for doc in cursor:
        vr = doc["_id"].get("vendor")
        pr = doc["_id"].get("product")
        sv = sanitizer(vr)
        sp = sanitizer(pr)
        if not sv or not sp:
            continue
        merged.setdefault((sv, sp), set()).update(doc["cves"])

    # overwrite dst_coll
    db[dst_coll].drop()
    db.create_collection(dst_coll)

    batch = []
    for (v, p), cves in merged.items():
        batch.append({
            "_id":       {"vendor": v, "product": p},
            "cves":      list(cves),
            "_build_ts": ts
        })
        if len(batch) >= BATCH_SIZE:
            db[dst_coll].insert_many(batch, ordered=False)
            batch.clear()
    if batch:
        db[dst_coll].insert_many(batch, ordered=False)

print("Transforming NVD map → sanitized keys…")
transform_map(MAP_NVD, MAP_NVD, sanitize_nvd_field)
final_nvd = db[MAP_NVD].count_documents({})
print(f" → {final_nvd:,} final NVD entries")

print("Transforming CVE-ListV5 map → sanitized keys…")
transform_map(MAP_CVELIST, MAP_CVELIST, sanitize_cvelist_field)
final_cl = db[MAP_CVELIST].count_documents({})
print(f" → {final_cl:,} final CVE-ListV5 entries")

# 4) Upsert metadata
db[META_COLL].update_one(
    {"collection": "nvd_ts",       "ts": ts},
    {"$setOnInsert": {"count": final_nvd}}, upsert=True
)
db[META_COLL].update_one(
    {"collection": "cvelistv5_ts", "ts": ts},
    {"$setOnInsert": {"count": final_cl}}, upsert=True
)

# 5) Create supporting indexes
print("Creating indexes…")
for coll_name, spec, idx_name in [
    (MAP_NVD,     [("_build_ts", 1)],            "idx_nvd_build_ts"),
    (MAP_NVD,     [("_build_ts", 1), ("_id", 1)],"idx_nvd_build_ts__id"),
    (MAP_CVELIST, [("_build_ts", 1)],            "idx_clv5_build_ts"),
    (MAP_CVELIST, [("_build_ts", 1), ("_id", 1)],"idx_clv5_build_ts__id"),
    (META_COLL,   [("collection", 1), ("ts", -1)],"idx_meta_collection_ts")
]:
    db[coll_name].create_index(spec, name=idx_name)

print("Map builds complete at", ts.isoformat())
