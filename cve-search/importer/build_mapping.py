#!/usr/bin/env python3
"""
1) Drop & recreate raw map collections each run.
2) Build raw NVD and CVE-ListV5 → vendor_raw / product_raw maps.
3) Apply sanitization, then append into sanitized maps (tagged by _build_ts).
4) Record build counts into map_build_meta via upserts.
5) Create all supporting indexes.
"""
from datetime import datetime, timezone
from pymongo import MongoClient

DB_NAME          = "cvedb"
NVD_COLL         = "cves"
CVELIST_COLL     = "cvelistv5"
RAW_MAP_NVD      = "map_vendor_product_nvd_raw"
RAW_MAP_CVELIST  = "map_vendor_product_cvelistv5_raw"
MAP_NVD          = "map_vendor_product_nvd"
MAP_CVELIST      = "map_vendor_product_cvelistv5"
META_COLL        = "map_build_meta"
BATCH_SIZE       = 1000

client = MongoClient("mongodb://mongo:27017/")
db     = client[DB_NAME]
ts     = datetime.now(timezone.utc)

def sanitize_nvd_field(s: str) -> str | None:
    if not s:
        return None
    s2 = s.strip()
    if not s2:
        return None
    low = s2.lower()
    if low in ("n/a", "*** n/a ***"):
        return None
    return low

def sanitize_cvelist_field(s: str) -> str | None:
    if not s:
        return None
    s2 = s.strip()
    if not s2:
        return None
    low = s2.lower()
    if low in ("n/a", "*** n/a ***"):
        return None
    return low

# 1) Drop & recreate only the RAW map collections each run
for coll in (RAW_MAP_NVD, RAW_MAP_CVELIST):
    if coll in db.list_collection_names():
        db[coll].drop()
    db.create_collection(coll)

# 1b) Ensure the sanitized‐map & meta collections exist (but do NOT drop them)
for coll in (MAP_NVD, MAP_CVELIST, META_COLL):
    if coll not in db.list_collection_names():
        db.create_collection(coll)

# 1c) Create indexes
db[META_COLL].create_index(
    [("collection", 1), ("ts", 1)],
    unique=True,
    name="uniq_meta_collection_ts"
)
db[MAP_NVD].create_index(
    [("vendor", 1), ("product", 1), ("_build_ts", 1)],
    unique=True,
    name="uniq_nvd_vendor_product_build_ts"
)
db[MAP_CVELIST].create_index(
    [("vendor", 1), ("product", 1), ("_build_ts", 1)],
    unique=True,
    name="uniq_clv5_vendor_product_build_ts"
)

# 2a) Build raw NVD → vendor_raw / product_raw map
print("Building raw map_vendor_product_nvd_raw …")
pipeline_nvd = [
    {"$unwind": "$configurations"},
    {"$unwind": "$configurations.nodes"},
    {"$unwind": "$configurations.nodes.cpeMatch"},
    {"$project": {
        "cve":        "$id",
        "vendor_raw":  {"$arrayElemAt": [
            {"$split": ["$configurations.nodes.cpeMatch.criteria", ":"]}, 3
        ]},
        "product_raw": {"$arrayElemAt": [
            {"$split": ["$configurations.nodes.cpeMatch.criteria", ":"]}, 4
        ]}
    }},
    {"$group": {
        "_id": {"vendor": "$vendor_raw", "product": "$product_raw"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$merge": {
        "into": RAW_MAP_NVD,
        "on":   "_id",
        "whenMatched": "replace",
        "whenNotMatched": "insert"
    }}
]
db[NVD_COLL].aggregate(pipeline_nvd, allowDiskUse=True)
print(f" → {db[RAW_MAP_NVD].count_documents({}):,} raw NVD entries")

# 2b) Build raw CVE-ListV5 → only CNA (drop ADP)
print("Building raw map_vendor_product_cvelistv5_raw …")
pipeline_cl = [
    {"$project": {
        "cve":     "$cveMetadata.cveId",
        "all_aff": {"$ifNull": ["$containers.cna.affected", []]}
    }},
    {"$unwind": "$all_aff"},
    {"$project": {
        "cve":         1,
        "vendor_raw":  "$all_aff.vendor",
        "product_raw": "$all_aff.product"
    }},
    {"$group": {
        "_id": {"vendor": "$vendor_raw", "product": "$product_raw"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$merge": {
        "into": RAW_MAP_CVELIST,
        "on":   "_id",
        "whenMatched": "replace",
        "whenNotMatched": "insert"
    }}
]
db[CVELIST_COLL].aggregate(pipeline_cl, allowDiskUse=True)
print(f" → {db[RAW_MAP_CVELIST].count_documents({}):,} raw CVE-ListV5 entries")

# 3) Transform & append into sanitized maps
def transform_map(src_coll: str, dst_coll: str, sanitizer):
    # safe retry: delete only this run’s docs
    db[dst_coll].delete_many({"_build_ts": ts})

    merged: dict[tuple[str, str], set[str]] = {}
    for doc in db[src_coll].find({}, {"_id": 1, "cves": 1}):
        raw_id = doc.get("_id")
        if not isinstance(raw_id, dict):
            continue

        vr = raw_id.get("vendor")
        pr = raw_id.get("product")
        sv = sanitizer(vr)
        sp = sanitizer(pr)
        if not sv or not sp:
            continue

        merged.setdefault((sv, sp), set()).update(doc["cves"])

    batch = []
    for (v, p), cves in merged.items():
        batch.append({
            "vendor":    v,
            "product":   p,
            "cves":      list(cves),
            "_build_ts": ts
        })
        if len(batch) >= BATCH_SIZE:
            db[dst_coll].insert_many(batch, ordered=False)
            batch.clear()
    if batch:
        db[dst_coll].insert_many(batch, ordered=False)

print("Transforming NVD raw → sanitized map_vendor_product_nvd …")
transform_map(RAW_MAP_NVD, MAP_NVD, sanitize_nvd_field)
final_nvd = db[MAP_NVD].count_documents({"_build_ts": ts})
print(f" → {final_nvd:,} final NVD entries for build {ts.isoformat()}")

print("Transforming CVE-ListV5 raw → sanitized map_vendor_product_cvelistv5 …")
transform_map(RAW_MAP_CVELIST, MAP_CVELIST, sanitize_cvelist_field)
final_cl = db[MAP_CVELIST].count_documents({"_build_ts": ts})
print(f" → {final_cl:,} final CVE-ListV5 entries for build {ts.isoformat()}")

# 4) Upsert metadata
db[META_COLL].update_one(
    {"collection": "nvd_ts",       "ts": ts},
    {"$setOnInsert": {"count": final_nvd}},
    upsert=True
)
db[META_COLL].update_one(
    {"collection": "cvelistv5_ts", "ts": ts},
    {"$setOnInsert": {"count": final_cl}},
    upsert=True
)

# 5) Create supporting indexes (no-ops if they already exist)
print("Creating additional indexes…")
for coll_name, spec, idx_name in [
    (MAP_NVD,     [("_build_ts", 1)],                                         "idx_nvd_build_ts"),
    (MAP_NVD,     [("_build_ts", 1), ("vendor", 1), ("product", 1)],         "idx_nvd_build_ts_vendor_product"),
    (MAP_CVELIST, [("_build_ts", 1)],                                         "idx_clv5_build_ts"),
    (MAP_CVELIST, [("_build_ts", 1), ("vendor", 1), ("product", 1)],         "idx_clv5_build_ts_vendor_product"),
    (META_COLL,   [("collection", 1), ("ts", -1)],                            "idx_meta_collection_ts")
]:
    db[coll_name].create_index(spec, name=idx_name)

print("Map builds complete at", ts.isoformat())
