#!/usr/bin/env python3
"""
1) Drop & recreate map and meta collections with the required unique indexes.
2) Build NVD and CVE-List → vendor/product maps (with _build_ts).
3) Record build counts into map_build_meta via Python upserts.
4) Recreate any additional supporting indexes.
"""
from datetime import datetime, timezone
from pymongo import MongoClient
from pymongo.errors import DuplicateKeyError

DB_NAME       = "cvedb"
NVD_COLL      = "cves"
CVELIST_COLL  = "cvelistv5"
MAP_NVD       = "map_vendor_product_nvd"
MAP_CVELIST   = "map_vendor_product_cvelistv5"
META_COLL     = "map_build_meta"

client = MongoClient("mongodb://mongo:27017/")
db     = client[DB_NAME]

# timestamp for this run
ts = datetime.now(timezone.utc)

# 1) Drop & recreate collections
db[MAP_NVD].drop()
db.create_collection(MAP_NVD)

db[MAP_CVELIST].drop()
db.create_collection(MAP_CVELIST)

db[META_COLL].drop()
db.create_collection(META_COLL)
# unique meta index
db[META_COLL].create_index(
    [("collection", 1), ("ts", 1)],
    unique=True,
    name="uniq_meta_collection_ts"
)

# 2a) Build NVD → vendor/product map
print("Building map_vendor_product_nvd…")
pipeline_nvd = [
    {"$unwind": "$configurations"},
    {"$unwind": "$configurations.nodes"},
    {"$unwind": "$configurations.nodes.cpeMatch"},
    {"$project": {
        "cve": "$id",
        "cpe": "$configurations.nodes.cpeMatch.criteria"
    }},
    {"$project": {
        "vendor":  {"$arrayElemAt": [{"$split": ["$cpe", ":"]}, 3]},
        "product": {"$arrayElemAt": [{"$split": ["$cpe", ":"]}, 4]},
        "cve": 1
    }},
    {"$group": {
        "_id": {"vendor": "$vendor", "product": "$product"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$set": {"_build_ts": ts}},
    {"$merge": {
        "into": MAP_NVD,
        "on":   "_id",
        "whenMatched":   "replace",
        "whenNotMatched":"insert"
    }}
]
db[NVD_COLL].aggregate(pipeline_nvd, allowDiskUse=True)
count_nvd = db[MAP_NVD].count_documents({})
print(" →", count_nvd, "entries")

# upsert meta
db[META_COLL].update_one(
    {"collection": "nvd_ts", "ts": ts},
    {"$setOnInsert": {"count": count_nvd}},
    upsert=True
)

# 2b) Build Official CVE-List → vendor/product map
print("Building map_vendor_product_cvelistv5…")
pipeline_cl = [
    {"$unwind": "$containers.cna.affected"},
    {"$group": {
        "_id": {
            "vendor":  "$containers.cna.affected.vendor",
            "product": "$containers.cna.affected.product"
        },
        "cves": {"$addToSet": "$cveMetadata.cveId"}
    }},
    {"$set": {"_build_ts": ts}},
    {"$merge": {
        "into": MAP_CVELIST,
        "on":   "_id",
        "whenMatched":   "replace",
        "whenNotMatched":"insert"
    }}
]
db[CVELIST_COLL].aggregate(pipeline_cl, allowDiskUse=True)
count_cl = db[MAP_CVELIST].count_documents({})
print(" →", count_cl, "entries")

# upsert meta
db[META_COLL].update_one(
    {"collection": "cvelistv5_ts", "ts": ts},
    {"$setOnInsert": {"count": count_cl}},
    upsert=True
)

# 3) Create any additional supporting indexes
print("Creating additional indexes…")
to_index = [
    (MAP_NVD,     [("_build_ts", 1)],                 "idx_nvd_build_ts"),
    (MAP_NVD,     [("_build_ts", 1), ("_id", 1)],     "idx_nvd_build_ts__id"),
    (MAP_CVELIST, [("_build_ts", 1)],                 "idx_clv5_build_ts"),
    (MAP_CVELIST, [("_build_ts", 1), ("_id", 1)],     "idx_clv5_build_ts__id"),
    (META_COLL,   [("collection", 1), ("ts", -1)],    "idx_meta_collection_ts")
]
for coll_name, spec, idx_name in to_index:
    db[coll_name].create_index(spec, name=idx_name)

print("Map builds complete at", ts.isoformat())
