#!/usr/bin/env python3
"""
1) Drop & recreate map and meta collections with the required unique indexes.
2) Build raw NVD and CVE-ListV5 → vendor/product maps (preserving hyphens, underscores, spaces).
3) In Python, unescape CPE backslashes + double any remaining backslashes + lowercase
   (but leave original -, _ and space), then re-group CVEs under those human-readable keys.
4) Record build counts into map_build_meta via upserts.
5) Create supporting indexes.
"""
from datetime import datetime, timezone
from pymongo import MongoClient

DB_NAME      = "cvedb"
NVD_COLL     = "cves"
CVELIST_COLL = "cvelistv5"
MAP_NVD      = "map_vendor_product_nvd"
MAP_CVELIST  = "map_vendor_product_cvelistv5"
META_COLL    = "map_build_meta"
BATCH_SIZE   = 1000

client = MongoClient("mongodb://mongo:27017/")
db     = client[DB_NAME]
ts     = datetime.now(timezone.utc)

def cpe_unescape(s: str) -> str:
    """
    Remove CPE-style escapes (\+, \!, \(, \), \~, \*) → +, !, (, ), ~, *
    then double any leftover single backslashes → "\\",
    lowercase, but leave hyphens, underscores and spaces intact.
    """
    if not s:
        return s
    for esc, char in [
        (r"\+", "+"),
        (r"\!", "!"),
        (r"\(", "("),
        (r"\)", ")"),
        (r"\~", "~"),
        (r"\*", "*"),
    ]:
        s = s.replace(esc, char)
    # now double any remaining single backslashes
    s = s.replace("\\", "\\\\")
    return s.lower()

# 1) Drop & recreate
db[MAP_NVD].drop();     db.create_collection(MAP_NVD)
db[MAP_CVELIST].drop(); db.create_collection(MAP_CVELIST)
db[META_COLL].drop();   db.create_collection(META_COLL)
db[META_COLL].create_index(
    [("collection", 1), ("ts", 1)],
    unique=True, name="uniq_meta_collection_ts"
)

# 2a) Build raw NVD map
print("Building raw map_vendor_product_nvd…")
pipeline_nvd = [
    {"$unwind": "$configurations"},
    {"$unwind": "$configurations.nodes"},
    {"$unwind": "$configurations.nodes.cpeMatch"},
    {"$project": {
        "cve":        "$id",
        "vendor_raw":  {"$arrayElemAt":[
            {"$split":["$configurations.nodes.cpeMatch.criteria", ":"]}, 3
        ]},
        "product_raw": {"$arrayElemAt":[
            {"$split":["$configurations.nodes.cpeMatch.criteria", ":"]}, 4
        ]}
    }},
    {"$group": {
        "_id": {"vendor": "$vendor_raw", "product": "$product_raw"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$merge": {
        "into": MAP_NVD,
        "on":   "_id",
        "whenMatched":   "replace",
        "whenNotMatched":"insert"
    }}
]
db[NVD_COLL].aggregate(pipeline_nvd, allowDiskUse=True)
raw_nvd = db[MAP_NVD].count_documents({})
print(f" → {raw_nvd:,} raw NVD entries")

# 2b) Build raw CVE-ListV5 map
print("Building raw map_vendor_product_cvelistv5…")
pipeline_cl = [
    {"$unwind": "$containers.cna.affected"},
    {"$project": {
        "cve":        "$cveMetadata.cveId",
        "vendor_raw":  "$containers.cna.affected.vendor",
        "product_raw": "$containers.cna.affected.product"
    }},
    {"$group": {
        "_id": {"vendor": "$vendor_raw", "product": "$product_raw"},
        "cves": {"$addToSet": "$cve"}
    }},
    {"$merge": {
        "into": MAP_CVELIST,
        "on":   "_id",
        "whenMatched":   "replace",
        "whenNotMatched":"insert"
    }}
]
db[CVELIST_COLL].aggregate(pipeline_cl, allowDiskUse=True)
raw_cl = db[MAP_CVELIST].count_documents({})
print(f" → {raw_cl:,} raw CVE-ListV5 entries")

# 3) Python-side unescape & re-group
def transform_map(src_coll, dst_coll):
    cursor = db[src_coll].find({}, {"_id":1, "cves":1})
    final = {}  # (vendor,product) -> set of CVEs

    for doc in cursor:
        idobj = doc.get("_id", {})
        if not isinstance(idobj, dict):
            continue
        vr = idobj.get("vendor")
        pr = idobj.get("product")
        if vr is None or pr is None:
            continue

        v = cpe_unescape(vr)
        p = cpe_unescape(pr)
        final.setdefault((v, p), set()).update(doc["cves"])

    # write transformed map back
    db[dst_coll].drop(); db.create_collection(dst_coll)
    batch = []
    for (v,p), cves in final.items():
        batch.append({
            "_id":       {"vendor": v, "product": p},
            "cves":      list(cves),
            "_build_ts": ts
        })
        if len(batch) >= BATCH_SIZE:
            db[dst_coll].insert_many(batch, ordered=False)
            batch.clear()
    if batch:
        db[dst_coll].insert_many(batch, ordered=False)

print("Transforming NVD map → human-readable keys…")
transform_map(MAP_NVD, MAP_NVD)
final_nvd = db[MAP_NVD].count_documents({})
print(f" → {final_nvd:,} final NVD entries")

print("Transforming CVE-ListV5 map → human-readable keys…")
transform_map(MAP_CVELIST, MAP_CVELIST)
final_cl = db[MAP_CVELIST].count_documents({})
print(f" → {final_cl:,} final CVE-ListV5 entries")

# 4) Upsert build metadata
db[META_COLL].update_one(
    {"collection": "nvd_ts",       "ts": ts},
    {"$setOnInsert": {"count": final_nvd}},
    upsert=True
)
db[META_COLL].update_one(
    {"collection": "cvelistv5_ts", "ts": ts},
    {"$setOnInsert": {"count": final_cl}},
    upsert=True
)

# 5) Create supporting indexes
print("Creating indexes…")
for coll, spec, name in [
    (MAP_NVD,     [("_build_ts",1)],           "idx_nvd_build_ts"),
    (MAP_NVD,     [("_build_ts",1),("_id",1)], "idx_nvd_build_ts__id"),
    (MAP_CVELIST, [("_build_ts",1)],           "idx_clv5_build_ts"),
    (MAP_CVELIST, [("_build_ts",1),("_id",1)], "idx_clv5_build_ts__id"),
    (META_COLL,   [("collection",1),("ts",-1)],"idx_meta_collection_ts"),
]:
    db[coll].create_index(spec, name=name)

print("Map builds complete at", ts.isoformat())
